#!/usr/bin/env bash

# @describe Whoxy API client for domain intelligence and reverse WHOIS lookups
# @arg command "Command to run (history, name, email, company, keyword)" [string]
# @arg value "Value to search for" [string]
# @option -k --key "Whoxy API key (can also use WHOXY_API_KEY env var)" [string]
# @option -p --page "Page number for results pagination" [int] @default "1"
# @option -m --mode "Result mode: normal, mini, micro, domains (domains only works with keyword)" [string] @default "normal"
# @flag   -j --json "Output raw JSON instead of formatted results"
# @flag   -q --quiet "Suppress colored output"
# @meta require-tools curl,jq

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Whoxy API client for domain intelligence and reverse WHOIS lookups

USAGE: whoxy [OPTIONS] [COMMAND] [VALUE]

ARGS:
  [COMMAND]  "Command to run (history, name, email, company, keyword)" [string]
  [VALUE]    "Value to search for" [string]

OPTIONS:
  -k, --key <KEY>    "Whoxy API key (can also use WHOXY_API_KEY env var)" [string]
  -p, --page <PAGE>  "Page number for results pagination" [int] @default "1"
  -m, --mode <MODE>  "Result mode: normal, mini, micro, domains (domains only works with keyword)" [string] @default "normal"
  -j, --json         "Output raw JSON instead of formatted results"
  -q, --quiet        "Suppress colored output"
  -h, --help         Print help
  -V, --version      Print version
EOF
    exit
}

_argc_version() {
    echo whoxy 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --key | -k)
            _argc_take_args "--key <KEY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_key:-}" ]]; then
                argc_key="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--key\` cannot be used multiple times"
            fi
            ;;
        --page | -p)
            _argc_take_args "--page <PAGE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_page:-}" ]]; then
                argc_page="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--page\` cannot be used multiple times"
            fi
            ;;
        --mode | -m)
            _argc_take_args "--mode <MODE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_mode:-}" ]]; then
                argc_mode="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--mode\` cannot be used multiple times"
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_command="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_value="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

# Setup colors
setup_colors() {
  if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" magenta="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) magenta=$(tput setaf 5) red=$(tput setaf 1)
  fi
}
setup_colors

# Get API key from multiple sources
get_api_key() {
  if [ -n "$argc_key" ]; then
    echo "$argc_key"
  elif [ -n "$WHOXY_API_KEY" ]; then
    echo "$WHOXY_API_KEY"
  elif [ -f "$HOME/.config/whoxy/api_key" ]; then
    cat "$HOME/.config/whoxy/api_key"
  else
    echo "${red}Error:${reset} No Whoxy API key found." >&2
    echo "Either:" >&2
    echo "  1. Pass it with --key" >&2
    echo "  2. Set WHOXY_API_KEY environment variable" >&2
    echo "  3. Save it to ~/.config/whoxy/api_key" >&2
    exit 1
  fi
}
API_KEY=$(get_api_key)

# Helper functions
print_kv() {
  printf "${bold}%s:${reset} %s\n" "$1" "$2"
}

print_section() {
  printf "\n${bold}%s:${reset}\n" "$1"
}

make_request() {
  local url="$1"
  local response=$(curl -s "$url")

  # Check for API errors
  if echo "$response" | jq -e '.status_code' >/dev/null 2>&1; then
    local status=$(echo "$response" | jq -r '.status_code')
    if [ "$status" != "1" ]; then
      local error_msg=$(echo "$response" | jq -r '.status_reason // "Unknown error"')
      printf "${red}Error:${reset} Whoxy API returned: ${red}%s${reset}\n" "$error_msg" >&2
      exit 1
    fi
  fi

  echo "$response"
}

format_contact() {
  local contact="$1"
  local type="$2"

  local name=$(echo "$contact" | jq -r '.full_name // "N/A"')
  local company=$(echo "$contact" | jq -r '.company_name // "N/A"')
  local email=$(echo "$contact" | jq -r '.email_address // "N/A"')
  local phone=$(echo "$contact" | jq -r '.phone_number // "N/A"')
  local street=$(echo "$contact" | jq -r '.street_address // "N/A"')
  local city=$(echo "$contact" | jq -r '.city_name // "N/A"')
  local state=$(echo "$contact" | jq -r '.state_name // "N/A"')
  local country=$(echo "$contact" | jq -r '.country_name // "N/A"')
  local zip=$(echo "$contact" | jq -r '.zip_code // "N/A"')

  printf "  ${bold}%s Contact:${reset}\n" "$type"
  [ "$name" != "N/A" ] && printf "    ${cyan}Name:${reset} ${green}%s${reset}\n" "$name"
  [ "$company" != "N/A" ] && printf "    ${cyan}Company:${reset} ${blue}%s${reset}\n" "$company"
  [ "$email" != "N/A" ] && printf "    ${cyan}Email:${reset} ${blue}%s${reset}\n" "$email"
  [ "$phone" != "N/A" ] && printf "    ${cyan}Phone:${reset} ${yellow}%s${reset}\n" "$phone"

  if [ "$street" != "N/A" ] || [ "$city" != "N/A" ] || [ "$state" != "N/A" ] || [ "$country" != "N/A" ] || [ "$zip" != "N/A" ]; then
    printf "    ${cyan}Address:${reset} "
    [ "$street" != "N/A" ] && printf "%s, " "$street"
    [ "$city" != "N/A" ] && printf "%s, " "$city"
    [ "$state" != "N/A" ] && printf "%s " "$state"
    [ "$zip" != "N/A" ] && printf "%s, " "$zip"
    [ "$country" != "N/A" ] && printf "%s" "$country"
    printf "\n"
  fi
}

format_history() {
  local response="$1"
  local domain=$(echo "$response" | jq -r '.domain_name // "N/A"')
  local total_pages=$(echo "$response" | jq -r '.total_pages // "N/A"')
  local total_records=$(echo "$response" | jq -r '.total_result // "N/A"')

  printf "${bold}Domain History:${reset} ${green}%s${reset}\n" "$domain"
  printf "${bold}Total Records:${reset} ${yellow}%s${reset} (${yellow}%s${reset} pages)\n" "$total_records" "$total_pages"

  echo "$response" | jq -r '.whois_records[] | "\(.query_time)|\(.registrant_contact)|\(.administrative_contact)"' |
    while IFS="|" read -r query_time registrant_raw admin_raw; do
      printf "\n${bold}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${reset}\n"
      printf "${bold}Query Time:${reset} ${yellow}%s${reset}\n" "$query_time"

      if [ "$registrant_raw" != "null" ]; then
        format_contact "$registrant_raw" "Registrant"
      fi

      if [ "$admin_raw" != "null" ]; then
        format_contact "$admin_raw" "Administrative"
      fi
    done
}

format_reverse_whois() {
  local response="$1"
  local search_type="$2"
  local search_value="$3"

  local total_results=$(echo "$response" | jq -r '.total_result // "N/A"')
  local total_pages=$(echo "$response" | jq -r '.total_pages // "N/A"')
  local current_page=$(echo "$response" | jq -r '.current_page // "N/A"')

  printf "${bold}Reverse WHOIS Search:${reset} ${green}%s${reset} = ${blue}%s${reset}\n" "$search_type" "$search_value"
  printf "${bold}Results:${reset} ${yellow}%s${reset} total (page ${yellow}%s${reset} of ${yellow}%s${reset})\n" "$total_results" "$current_page" "$total_pages"

  # Handle different result modes
  if [ "$argc_mode" = "domains" ]; then
    print_section "Domain Names"
    echo "$response" | jq -r '.search_result[]' | while read -r domain; do
      printf "  ${green}%s${reset}\n" "$domain"
    done
  elif [ "$argc_mode" = "micro" ]; then
    print_section "Micro Results"
    echo "$response" | jq -r '.search_result[] | "\(.domain_name)|\(.create_date)|\(.update_date)|\(.expire_date)"' |
      while IFS="|" read -r domain create update expire; do
        printf "${bold}* ${green}%s${reset}\n" "$domain"
        [ "$create" != "null" ] && printf "  ${cyan}Created:${reset} ${yellow}%s${reset}\n" "$create"
        [ "$update" != "null" ] && printf "  ${cyan}Updated:${reset} ${yellow}%s${reset}\n" "$update"
        [ "$expire" != "null" ] && printf "  ${cyan}Expires:${reset} ${yellow}%s${reset}\n" "$expire"
      done
  elif [ "$argc_mode" = "mini" ]; then
    print_section "Mini Results"
    echo "$response" | jq -r '.search_result[] | "\(.domain_name)|\(.registrant_contact.full_name // "N/A")|\(.registrant_contact.email_address // "N/A")|\(.registrant_contact.company_name // "N/A")"' |
      while IFS="|" read -r domain name email company; do
        printf "${bold}* ${green}%s${reset}\n" "$domain"
        [ "$name" != "N/A" ] && printf "  ${cyan}Name:${reset} ${blue}%s${reset}\n" "$name"
        [ "$email" != "N/A" ] && printf "  ${cyan}Email:${reset} ${blue}%s${reset}\n" "$email"
        [ "$company" != "N/A" ] && printf "  ${cyan}Company:${reset} ${magenta}%s${reset}\n" "$company"
      done
  else
    # Normal mode - process each record individually
    print_section "Full Results"

    # Get the length of the search_result array
    local length=$(echo "$response" | jq '.search_result | length')

    for ((i = 0; i < length; i++)); do
      local record=$(echo "$response" | jq ".search_result[$i]")

      local domain=$(echo "$record" | jq -r '.domain_name // "N/A"')
      local create=$(echo "$record" | jq -r '.create_date // "null"')
      local update=$(echo "$record" | jq -r '.update_date // "null"')
      local expire=$(echo "$record" | jq -r '.expire_date // "null"')

      printf "\n${bold}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${reset}\n"
      printf "${bold}Domain:${reset} ${green}%s${reset}\n" "$domain"

      if [ "$create" != "null" ] || [ "$update" != "null" ] || [ "$expire" != "null" ]; then
        printf "${bold}Dates:${reset} "
        [ "$create" != "null" ] && printf "Created: ${yellow}%s${reset}  " "$create"
        [ "$update" != "null" ] && printf "Updated: ${yellow}%s${reset}  " "$update"
        [ "$expire" != "null" ] && printf "Expires: ${yellow}%s${reset}" "$expire"
        printf "\n"
      fi

      # Process contacts separately to avoid JSON parsing issues
      local registrant_contact=$(echo "$record" | jq '.registrant_contact // null')
      local admin_contact=$(echo "$record" | jq '.administrative_contact // null')

      if [ "$registrant_contact" != "null" ]; then
        format_contact "$registrant_contact" "Registrant"
      fi

      if [ "$admin_contact" != "null" ]; then
        format_contact "$admin_contact" "Administrative"
      fi
    done
  fi
}

show_help() {
  echo "${bold}Whoxy API Client${reset}"
  echo ""
  echo "${bold}Commands:${reset}"
  echo "  ${cyan}history${reset}       Get domain history lookup"
  echo "  ${cyan}name${reset}          Search by domain owner's name"
  echo "  ${cyan}email${reset}         Search by email address"
  echo "  ${cyan}company${reset}       Search by company/organization name"
  echo "  ${cyan}keyword${reset}       Search by keyword at start of domain name"
  echo ""
  echo "${bold}Examples:${reset}"
  echo "  ${green}$(basename "$0") history example.com${reset}"
  echo "  ${green}$(basename "$0") name \"John Doe\"${reset}"
  echo "  ${green}$(basename "$0") email john@example.com${reset}"
  echo "  ${green}$(basename "$0") company \"Example Corp\"${reset}"
  echo "  ${green}$(basename "$0") keyword example --mode domains${reset}"
  echo ""
  echo "${bold}Options:${reset}"
  echo "  ${yellow}-k, --key${reset}     Whoxy API key"
  echo "  ${yellow}-p, --page${reset}    Page number for results pagination"
  echo "  ${yellow}-m, --mode${reset}    Result mode (normal, mini, micro, domains)"
  echo "  ${yellow}-j, --json${reset}    Output raw JSON"
  echo "  ${yellow}-q, --quiet${reset}   Suppress colored output"
  echo ""
  echo "${bold}Modes:${reset}"
  echo "  ${cyan}normal${reset}        Full contact information (default)"
  echo "  ${cyan}mini${reset}          Basic contact info only"
  echo "  ${cyan}micro${reset}         Domain names with dates only"
  echo "  ${cyan}domains${reset}       Domain names only (keyword search only)"
}

# Main command processing
if [ -z "$argc_command" ]; then
  show_help
  exit 0
fi

if [ -z "$argc_value" ]; then
  echo "${red}Error:${reset} Search value is required." >&2
  exit 1
fi

# Validate mode for keyword search
if [ "$argc_mode" = "domains" ] && [ "$argc_command" != "keyword" ]; then
  echo "${red}Error:${reset} domains mode can only be used with keyword search" >&2
  exit 1
fi

# Process commands
case "$argc_command" in
history)
  url="https://api.whoxy.com/?key=${API_KEY}&history=${argc_value}"
  response=$(make_request "$url")
  [ "$argc_json" = 1 ] && echo "$response" | jq || format_history "$response"
  ;;

name | email | company | keyword)
  url="https://api.whoxy.com/?key=${API_KEY}&reverse=whois&${argc_command}=${argc_value}"

  if [ "$argc_page" != "1" ]; then
    url="${url}&page=${argc_page}"
  fi

  if [ "$argc_mode" != "normal" ]; then
    url="${url}&mode=${argc_mode}"
  fi

  # URL encode spaces
  url=$(echo "$url" | sed 's/ /+/g')

  response=$(make_request "$url")
  [ "$argc_json" = 1 ] && echo "$response" | jq || format_reverse_whois "$response" "$argc_command" "$argc_value"
  ;;

*)
  echo "${red}Error:${reset} Unknown command: ${argc_command}" >&2
  show_help
  exit 1
  ;;
esac
